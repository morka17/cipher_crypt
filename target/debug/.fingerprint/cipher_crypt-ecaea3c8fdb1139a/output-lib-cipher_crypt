{"message":"`&[u8]` is not an iterator","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src\\transportation_cipher.rs","byte_start":1187,"byte_end":1196,"line_start":35,"line_end":35,"column_start":69,"column_end":78,"is_primary":true,"text":[{"text":"        let mut key_ascii: Vec<(usize, u8)> = cipher_key.as_bytes().enumerate().collect::<Vec<(usize, u8)>>();","highlight_start":69,"highlight_end":78}],"label":"`&[u8]` is not an iterator; try calling `.iter()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`&[u8]: Iterator`\nwhich is required by `&mut &[u8]: Iterator`\n`[u8]: Iterator`\nwhich is required by `&mut [u8]: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: `&[u8]` is not an iterator\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\transportation_cipher.rs:35:69\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut key_ascii: Vec<(usize, u8)> = cipher_key.as_bytes().enumerate().collect::<Vec<(usize, u8)>>();\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m`&[u8]` is not an iterator; try calling `.iter()`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: the following trait bounds were not satisfied:\u001b[0m\n\u001b[0m           `&[u8]: Iterator`\u001b[0m\n\u001b[0m           which is required by `&mut &[u8]: Iterator`\u001b[0m\n\u001b[0m           `[u8]: Iterator`\u001b[0m\n\u001b[0m           which is required by `&mut [u8]: Iterator`\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\transportation_cipher.rs","byte_start":663,"byte_end":1248,"line_start":22,"line_end":38,"column_start":5,"column_end":6,"is_primary":true,"text":[{"text":"    for cipher_key in keys.iter(){","highlight_start":5,"highlight_end":35},{"text":"        let mut key_order: Vec<usize> = Vec::new();","highlight_start":1,"highlight_end":52},{"text":"        let mut counter: u8 = 0;","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Removes any non-alphabet characters from 'msg'","highlight_start":1,"highlight_end":58},{"text":"        cipher_msg = cipher_msg ","highlight_start":1,"highlight_end":33},{"text":"        .to_uppercase()","highlight_start":1,"highlight_end":24},{"text":"        .chars()","highlight_start":1,"highlight_end":17},{"text":"        .filter(|&c| c.is_ascii_alphabetic())","highlight_start":1,"highlight_end":46},{"text":"        .collect();","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Determines the sequence of the columns, as dictated by the ","highlight_start":1,"highlight_end":71},{"text":"        // alphabetical order of the keyword's letters ","highlight_start":1,"highlight_end":56},{"text":"        let mut key_ascii: Vec<(usize, u8)> = cipher_key.as_bytes().enumerate().collect::<Vec<(usize, u8)>>();","highlight_start":1,"highlight_end":111},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"expected struct `String`, found `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\transportation_cipher.rs","byte_start":663,"byte_end":1248,"line_start":22,"line_end":38,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    for cipher_key in keys.iter(){","highlight_start":5,"highlight_end":35},{"text":"        let mut key_order: Vec<usize> = Vec::new();","highlight_start":1,"highlight_end":52},{"text":"        let mut counter: u8 = 0;","highlight_start":1,"highlight_end":33},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Removes any non-alphabet characters from 'msg'","highlight_start":1,"highlight_end":58},{"text":"        cipher_msg = cipher_msg ","highlight_start":1,"highlight_end":33},{"text":"        .to_uppercase()","highlight_start":1,"highlight_end":24},{"text":"        .chars()","highlight_start":1,"highlight_end":17},{"text":"        .filter(|&c| c.is_ascii_alphabetic())","highlight_start":1,"highlight_end":46},{"text":"        .collect();","highlight_start":1,"highlight_end":20},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Determines the sequence of the columns, as dictated by the ","highlight_start":1,"highlight_end":71},{"text":"        // alphabetical order of the keyword's letters ","highlight_start":1,"highlight_end":56},{"text":"        let mut key_ascii: Vec<(usize, u8)> = cipher_key.as_bytes().enumerate().collect::<Vec<(usize, u8)>>();","highlight_start":1,"highlight_end":111},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `for` loop","def_site_span":{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\transportation_cipher.rs","byte_start":356,"byte_end":362,"line_start":13,"line_end":13,"column_start":67,"column_end":73,"is_primary":false,"text":[{"text":"pub fn transportation(decrypt_mode:bool, msg: &str, key: &str) -> String {","highlight_start":67,"highlight_end":73}],"label":"expected `String` because of return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: mismatched types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\transportation_cipher.rs:22:5\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0mpub fn transportation(decrypt_mode:bool, msg: &str, key: &str) -> String {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mexpected `String` because of return type\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m22\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    for cipher_key in keys.iter(){\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m23\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut key_order: Vec<usize> = Vec::new();\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m24\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        let mut counter: u8 = 0;\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m37\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m38\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_____^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected struct `String`, found `()`\u001b[0m\n\n"}
{"message":"aborting due to 2 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to 2 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0308, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mSome errors have detailed explanations: E0308, E0599.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0308`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about an error, try `rustc --explain E0308`.\u001b[0m\n"}
